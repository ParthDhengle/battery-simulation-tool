import numpy as np

def calculate_module_voltage(cells, V_parallel_matrix, I_module, R_s, t, V_terminal_module_matrix):
    """
    Calculates and stores the module terminal voltage at time step t.

    Args:
        cells (list of dict): List of cell properties, including 'parallel_group'.
        V_parallel_matrix (np.ndarray): Matrix of parallel voltages [N_cells x time_steps].
        I_module (np.ndarray): Module current array [time_steps].
        R_s (float): Series interconnect resistance.
        t (int): Current time step (0-based).
        V_terminal_module_matrix (np.ndarray): Vector to store module terminal voltage.

    Returns:
        np.ndarray: Updated V_terminal_module_matrix with voltage at time t.
    """
    # Get unique parallel group IDs
    parallel_groups = sorted(set(cell['parallel_group'] for cell in cells))

    # Number of series connections = one less than number of parallel groups
    num_series_connections = len(parallel_groups) - 1

    # Sum the voltages from one representative cell per group
    V_sum_parallel_groups = 0.0
    for group_id in parallel_groups:
        for cell_idx, cell in enumerate(cells):
            if cell['parallel_group'] == group_id:
                V_sum_parallel_groups += V_parallel_matrix[cell_idx, t]
                break  # Only need one cell's voltage per group

    # Compute total terminal voltage
    V_terminal_module = V_sum_parallel_groups - I_module[t] * (num_series_connections + 1) * R_s

    # Store in matrix
    V_terminal_module_matrix[t] = V_terminal_module

    return V_terminal_module_matrix
